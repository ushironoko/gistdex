import type { DocAnalysisResult } from "./doc-service.js";

/**
 * Format results as Markdown
 */
export const formatMarkdown = (
  results: DocAnalysisResult[],
  threshold: number,
): string => {
  if (results.length === 0) {
    return "## 📚 Documentation Impact Analysis\n\n✅ No documentation impact detected";
  }

  const lines: string[] = [
    "## 📚 Documentation Impact Analysis",
    "",
    `Found ${results.length} documentation file${results.length === 1 ? "" : "s"} with potential impact:`,
    "",
  ];

  // Sort by similarity (highest first)
  const sorted = [...results].sort((a, b) => b.similarity - a.similarity);

  for (const result of sorted) {
    const similarity = (result.similarity * 100).toFixed(1);
    const icon = getImpactIcon(result.similarity);

    lines.push(`${icon} \`${result.file}\` (similarity: ${similarity}%)`);

    if (result.matchedTerms && result.matchedTerms.length > 0) {
      lines.push(`   - Matched: ${result.matchedTerms.slice(0, 5).join(", ")}`);
    }
  }

  lines.push("");
  lines.push(`> Threshold: ${(threshold * 100).toFixed(0)}%`);

  return lines.join("\n");
};

/**
 * Format results for GitHub PR comment
 */
export const formatGitHubComment = (
  results: DocAnalysisResult[],
  threshold: number,
): string => {
  if (results.length === 0) {
    return `## 📚 Documentation Impact Analysis

✅ **No documentation impact detected**

All documentation appears to be unaffected by the code changes.`;
  }

  const lines: string[] = ["## 📚 Documentation Impact Analysis", ""];

  // Group by impact level
  const high = results.filter((r) => r.similarity >= 0.8);
  const medium = results.filter(
    (r) => r.similarity >= 0.5 && r.similarity < 0.8,
  );
  const low = results.filter((r) => r.similarity < 0.5);

  if (high.length > 0) {
    lines.push("### 🔴 High Impact (>80% similarity)");
    lines.push("");
    for (const result of high) {
      lines.push(formatGitHubResultLine(result));
    }
    lines.push("");
  }

  if (medium.length > 0) {
    lines.push("### 🟡 Medium Impact (50-80% similarity)");
    lines.push("");
    for (const result of medium) {
      lines.push(formatGitHubResultLine(result));
    }
    lines.push("");
  }

  if (low.length > 0) {
    lines.push("<details>");
    lines.push("<summary>🟢 Low Impact (<50% similarity)</summary>");
    lines.push("");
    for (const result of low) {
      lines.push(formatGitHubResultLine(result));
    }
    lines.push("");
    lines.push("</details>");
    lines.push("");
  }

  lines.push("---");
  lines.push("");

  lines.push(
    `📊 **Summary**: ${results.length} documentation file${results.length === 1 ? "" : "s"} may need review`,
  );
  lines.push(`🎯 **Threshold**: ${(threshold * 100).toFixed(0)}%`);
  lines.push("");
  lines.push(
    "_Generated by [Gistdex CI](https://github.com/ushironoko/gistdex)_",
  );

  return lines.join("\n");
};

/**
 * Format a single result line for GitHub
 */
const formatGitHubResultLine = (result: DocAnalysisResult): string => {
  const similarity = (result.similarity * 100).toFixed(1);
  const changeIcon = getChangeTypeIcon(result.changeType);

  // Format file name with optional line numbers link
  let fileDisplay = `\`${result.file}\``;
  if (result.githubUrl && result.startLine && result.endLine) {
    // Add clickable line number range
    fileDisplay += ` [(L${result.startLine}-L${result.endLine})](${result.githubUrl})`;
  } else if (result.githubUrl && result.startLine) {
    // Single line reference
    fileDisplay += ` [(L${result.startLine})](${result.githubUrl})`;
  }

  let line = `- ${changeIcon} **${fileDisplay}** _(${similarity}% similarity)_`;

  if (result.matchedTerms && result.matchedTerms.length > 0) {
    const terms = result.matchedTerms
      .slice(0, 3)
      .map((t: string) => `\`${t}\``)
      .join(", ");
    line += `\n  - Matched: ${terms}`;
    if (result.matchedTerms.length > 3) {
      line += ` +${result.matchedTerms.length - 3} more`;
    }
  }

  return line;
};

/**
 * Format results as JSON
 */
export const formatJSON = (
  results: DocAnalysisResult[],
  threshold: number,
  diffRange?: string,
): string => {
  return JSON.stringify(
    {
      timestamp: new Date().toISOString(),
      diffRange,
      threshold,
      impactCount: results.length,
      results: results.map((r) => ({
        ...r,
        similarityPercent: (r.similarity * 100).toFixed(1),
      })),
    },
    null,
    2,
  );
};

/**
 * Get impact level icon based on similarity score
 */
const getImpactIcon = (similarity: number): string => {
  if (similarity >= 0.8) return "🔴";
  if (similarity >= 0.5) return "🟡";
  return "🟢";
};

/**
 * Get change type icon
 */
const getChangeTypeIcon = (changeType: string): string => {
  switch (changeType) {
    case "added":
      return "➕";
    case "deleted":
      return "➖";
    default:
      return "📝";
  }
};
