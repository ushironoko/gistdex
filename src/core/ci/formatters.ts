import type { DocAnalysisResult } from "./doc-service.js";

/**
 * Format results for GitHub PR comment
 */
export const formatGitHubComment = (
  results: DocAnalysisResult[],
  threshold: number,
): string => {
  if (results.length === 0) {
    return `## ğŸ“š Documentation Impact Analysis

âœ… **No documentation impact detected**

All documentation appears to be unaffected by the code changes.`;
  }

  const lines: string[] = ["## ğŸ“š Documentation Impact Analysis", ""];

  // Group by impact level
  const high = results.filter((r) => r.similarity >= 0.8);
  const medium = results.filter(
    (r) => r.similarity >= 0.5 && r.similarity < 0.8,
  );
  const low = results.filter((r) => r.similarity < 0.5);

  if (high.length > 0) {
    lines.push("### ğŸ”´ High Impact (>80% similarity)");
    lines.push("");
    for (const result of high) {
      lines.push(formatGitHubResultLine(result));
    }
    lines.push("");
  }

  if (medium.length > 0) {
    lines.push("### ğŸŸ¡ Medium Impact (50-80% similarity)");
    lines.push("");
    for (const result of medium) {
      lines.push(formatGitHubResultLine(result));
    }
    lines.push("");
  }

  if (low.length > 0) {
    lines.push("<details>");
    lines.push("<summary>ğŸŸ¢ Low Impact (<50% similarity)</summary>");
    lines.push("");
    for (const result of low) {
      lines.push(formatGitHubResultLine(result));
    }
    lines.push("");
    lines.push("</details>");
    lines.push("");
  }

  lines.push("---");
  lines.push("");

  lines.push(
    `ğŸ“Š **Summary**: ${results.length} documentation file${results.length === 1 ? "" : "s"} may need review`,
  );
  lines.push(`ğŸ¯ **Threshold**: ${(threshold * 100).toFixed(0)}%`);
  lines.push("");
  lines.push(
    "_Generated by [Gistdex CI](https://github.com/ushironoko/gistdex)_",
  );

  return lines.join("\n");
};

/**
 * Normalize file paths for GitHub Actions environment
 */
const normalizeFilePath = (filePath: string): string => {
  // Remove GitHub Actions workspace path prefix
  const workspacePrefixes: string[] = [];

  // Get repository name from GITHUB_REPOSITORY env var
  const repository = process.env.GITHUB_REPOSITORY;
  if (repository) {
    const repoName = repository.split("/")[1];
    if (repoName) {
      // Add the standard GitHub Actions workspace path
      workspacePrefixes.push(`/home/runner/work/${repoName}/${repoName}/`);
    }
  }

  // Add GITHUB_WORKSPACE if available
  if (process.env.GITHUB_WORKSPACE) {
    workspacePrefixes.push(`${process.env.GITHUB_WORKSPACE}/`);
  }

  for (const prefix of workspacePrefixes.filter(Boolean)) {
    if (filePath.startsWith(prefix)) {
      return filePath.substring(prefix.length);
    }
  }

  // If already a relative path, return as is
  if (!filePath.startsWith("/")) {
    return filePath;
  }

  // For other absolute paths, try to extract relative portion based on repository name
  if (repository) {
    const repoName = repository.split("/")[1];
    if (repoName) {
      const match = filePath.match(new RegExp(`(?:.*/)?${repoName}/(.*)`));
      return match?.[1] ?? filePath;
    }
  }

  return filePath;
};

/**
 * Format a single result line for GitHub
 */
const formatGitHubResultLine = (result: DocAnalysisResult): string => {
  const similarity = (result.similarity * 100).toFixed(1);
  const changeIcon = getChangeTypeIcon(result.changeType);

  // Normalize file path
  const normalizedFile = normalizeFilePath(result.file);

  // Format file name with optional line numbers link
  let fileDisplay = `\`${normalizedFile}\``;
  if (result.githubUrl && result.startLine && result.endLine) {
    // Add clickable line number range
    fileDisplay += ` [(L${result.startLine}-L${result.endLine})](${result.githubUrl})`;
  } else if (result.githubUrl && result.startLine) {
    // Single line reference
    fileDisplay += ` [(L${result.startLine})](${result.githubUrl})`;
  }

  let line = `- ${changeIcon} **${fileDisplay}** _(${similarity}% similarity)_`;

  if (result.matchedTerms && result.matchedTerms.length > 0) {
    const terms = result.matchedTerms
      .slice(0, 3)
      .map((t: string) => `\`${t}\``)
      .join(", ");
    line += `\n  - Matched: ${terms}`;
    if (result.matchedTerms.length > 3) {
      line += ` +${result.matchedTerms.length - 3} more`;
    }
  }

  return line;
};

/**
 * Format results as JSON
 */
export const formatJSON = (
  results: DocAnalysisResult[],
  threshold: number,
  diffRange?: string,
): string => {
  return JSON.stringify(
    {
      timestamp: new Date().toISOString(),
      diffRange,
      threshold,
      impactCount: results.length,
      results: results.map((r) => ({
        file: normalizeFilePath(r.file),
        score: r.similarity, // Keep original score field for compatibility
        similarity: r.similarity, // Add similarity field for post-github-comment.ts
        matchedChunks: r.matchedTerms?.length ?? 0, // Provide default value
        totalChunks: r.matchedTerms?.length ?? 0, // Provide default value (same as matched for now)
        similarityPercent: (r.similarity * 100).toFixed(1),
        matchedTerms: r.matchedTerms,
        sections: r.matchedTerms, // Use matchedTerms as sections for compatibility
        metadata: {
          changeType: r.changeType,
          startLine: r.startLine,
          endLine: r.endLine,
          githubUrl: r.githubUrl,
        },
      })),
    },
    null,
    2,
  );
};

/**
 * Get change type icon
 */
const getChangeTypeIcon = (changeType: string): string => {
  switch (changeType) {
    case "added":
      return "â•";
    case "deleted":
      return "â–";
    default:
      return "ğŸ“";
  }
};
