import { describe, expect, it } from "vitest";
import type { DocAnalysisResult } from "./doc-service.js";
import {
  formatGitHubComment,
  formatJSON,
  formatMarkdown,
} from "./formatters.js";

describe("formatters", () => {
  const createMockResults = (count: number): DocAnalysisResult[] => {
    const results: DocAnalysisResult[] = [];
    for (let i = 0; i < count; i++) {
      results.push({
        file: `docs/file${i}.md`,
        similarity: 0.9 - i * 0.1,
        matchedTerms: [`term${i}`, `keyword${i}`],
        changeType: i % 2 === 0 ? "modified" : "added",
      });
    }
    return results;
  };

  describe("formatMarkdown", () => {
    it("should format empty results", () => {
      const output = formatMarkdown([], 0.7);
      expect(output).toContain("No documentation impact detected");
    });

    it("should format results with similarity scores", () => {
      const results = createMockResults(2);
      const output = formatMarkdown(results, 0.7);

      expect(output).toContain("Documentation Impact Analysis");
      expect(output).toContain("docs/file0.md");
      expect(output).toContain("90.0%");
      expect(output).toContain("docs/file1.md");
      expect(output).toContain("80.0%");
      expect(output).toContain("Threshold: 70%");
    });

    it("should include matched terms", () => {
      const results: DocAnalysisResult[] = [
        {
          file: "README.md",
          similarity: 0.85,
          matchedTerms: ["authenticate", "getUserProfile"],
          changeType: "deleted",
        },
      ];
      const output = formatMarkdown(results, 0.5);

      expect(output).toContain("authenticate");
      expect(output).toContain("getUserProfile");
    });

    it("should use correct impact icons", () => {
      const results: DocAnalysisResult[] = [
        { file: "high.md", similarity: 0.85, changeType: "modified" },
        { file: "medium.md", similarity: 0.6, changeType: "modified" },
        { file: "low.md", similarity: 0.3, changeType: "modified" },
      ];
      const output = formatMarkdown(results, 0.3);

      expect(output).toContain("ðŸ”´"); // High impact
      expect(output).toContain("ðŸŸ¡"); // Medium impact
      expect(output).toContain("ðŸŸ¢"); // Low impact
    });
  });

  describe("formatGitHubComment", () => {
    it("should format empty results with friendly message", () => {
      const output = formatGitHubComment([], 0.7);
      expect(output).toContain("No documentation impact detected");
      expect(output).toContain("All documentation appears to be unaffected");
    });

    it("should group results by impact level", () => {
      const results: DocAnalysisResult[] = [
        { file: "high1.md", similarity: 0.9, changeType: "modified" },
        { file: "high2.md", similarity: 0.85, changeType: "deleted" },
        { file: "medium.md", similarity: 0.6, changeType: "added" },
        { file: "low.md", similarity: 0.3, changeType: "modified" },
      ];
      const output = formatGitHubComment(results, 0.3);

      expect(output).toContain("High Impact (>80% similarity)");
      expect(output).toContain("Medium Impact (50-80% similarity)");
      expect(output).toContain("<details>");
      expect(output).toContain("Low Impact (<50% similarity)");
    });

    it("should include change type icons", () => {
      const results: DocAnalysisResult[] = [
        { file: "added.md", similarity: 0.9, changeType: "added" },
        { file: "deleted.md", similarity: 0.85, changeType: "deleted" },
        { file: "modified.md", similarity: 0.8, changeType: "modified" },
      ];
      const output = formatGitHubComment(results, 0.5);

      expect(output).toContain("âž•"); // Added
      expect(output).toContain("âž–"); // Deleted
      expect(output).toContain("ðŸ“"); // Modified
    });

    it("should include summary and Gistdex branding", () => {
      const results = createMockResults(3);
      const output = formatGitHubComment(results, 0.5);

      expect(output).toContain("Summary");
      expect(output).toContain("3 documentation files may need review");
      expect(output).toContain("**Threshold**: 50%");
      expect(output).toContain("Generated by [Gistdex CI]");
    });

    it("should limit matched terms display", () => {
      const results: DocAnalysisResult[] = [
        {
          file: "test.md",
          similarity: 0.9,
          changeType: "modified",
          matchedTerms: ["term1", "term2", "term3", "term4", "term5"],
        },
      ];
      const output = formatGitHubComment(results, 0.5);

      expect(output).toContain("`term1`");
      expect(output).toContain("`term2`");
      expect(output).toContain("`term3`");
      expect(output).toContain("+2 more");
    });
  });

  describe("formatJSON", () => {
    it("should format results as JSON", () => {
      const results = createMockResults(2);
      const output = formatJSON(results, 0.7, "HEAD~1..HEAD");

      const parsed = JSON.parse(output);

      expect(parsed.diffRange).toBe("HEAD~1..HEAD");
      expect(parsed.threshold).toBe(0.7);
      expect(parsed.impactCount).toBe(2);
      expect(parsed.results).toHaveLength(2);
      expect(parsed.timestamp).toBeDefined();
    });

    it("should include similarity percentage in JSON", () => {
      const results: DocAnalysisResult[] = [
        {
          file: "test.md",
          similarity: 0.856,
          changeType: "modified",
        },
      ];
      const output = formatJSON(results, 0.5);

      const parsed = JSON.parse(output);
      expect(parsed.results[0].similarityPercent).toBe("85.6");
    });

    it("should handle empty results", () => {
      const output = formatJSON([], 0.7);

      const parsed = JSON.parse(output);

      expect(parsed.impactCount).toBe(0);
      expect(parsed.results).toEqual([]);
    });

    it("should be properly formatted JSON", () => {
      const results = createMockResults(1);
      const output = formatJSON(results, 0.7);

      // Check indentation (2 spaces)
      expect(output).toMatch(/\n {2}"/);

      // Should not throw when parsing
      expect(() => JSON.parse(output)).not.toThrow();
    });
  });
});
