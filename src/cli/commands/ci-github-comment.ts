#!/usr/bin/env node

import { readFile } from "node:fs/promises";
import { exit } from "node:process";

interface DocAnalysisResult {
  file: string;
  similarity: number;
  matchedTerms?: string[];
  changeType: "added" | "modified" | "deleted";
}

interface GitHubComment {
  id: number;
  user: {
    type?: string;
  } | null;
  body?: string | null;
}

/**
 * Create a GitHub PR comment from documentation analysis results
 */
export const createPRComment = (results: DocAnalysisResult[]): string => {
  if (!Array.isArray(results) || results.length === 0) {
    throw new Error("No documentation impacts found");
  }

  // Build comment body
  let comment = "## ðŸ“š Documentation Impact Analysis\n\n";
  comment += `This PR may affect ${results.length} documentation file(s).\n\n`;

  // Group by change type
  const byType: Record<string, DocAnalysisResult[]> = {};
  for (const result of results) {
    const type = result.changeType || "modified";
    if (!byType[type]) byType[type] = [];
    byType[type].push(result);
  }

  // Format results
  const typeEmojis = {
    added: "ðŸ†•",
    modified: "ðŸ“",
    deleted: "ðŸ—‘ï¸",
  } as const;

  for (const [type, docs] of Object.entries(byType)) {
    const emoji = typeEmojis[type as keyof typeof typeEmojis] || "ðŸ“„";
    comment += `### ${emoji} ${type.charAt(0).toUpperCase() + type.slice(1)} Code\n\n`;

    for (const doc of docs) {
      const similarity = ((doc.similarity || 0) * 100).toFixed(1);
      comment += `- **${doc.file}** (${similarity}% relevance)\n`;

      if (doc.matchedTerms && doc.matchedTerms.length > 0) {
        const terms = doc.matchedTerms
          .slice(0, 5)
          .map((t) => `\`${t}\``)
          .join(", ");
        comment += `  - Related: ${terms}\n`;
      }
    }
    comment += "\n";
  }

  comment += "---\n";
  comment += "_Generated by Gistdex CI Documentation Analysis_";

  return comment;
};

/**
 * Post or update a GitHub PR comment
 */
export const postGitHubComment = async (
  owner: string,
  repo: string,
  issueNumber: number,
  comment: string,
  token: string,
): Promise<void> => {
  const apiUrl = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/comments`;

  // Get existing comments
  const listResponse = await fetch(apiUrl, {
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github.v3+json",
    },
  });

  if (!listResponse.ok) {
    throw new Error(
      `Failed to fetch comments: ${listResponse.status} ${listResponse.statusText}`,
    );
  }

  const comments = (await listResponse.json()) as GitHubComment[];

  // Find existing bot comment
  const botComment = comments.find(
    (c) =>
      c.user?.type === "Bot" &&
      c.body?.includes("Documentation Impact Analysis"),
  );

  if (botComment) {
    // Update existing comment
    const updateUrl = `https://api.github.com/repos/${owner}/${repo}/issues/comments/${botComment.id}`;
    const updateResponse = await fetch(updateUrl, {
      method: "PATCH",
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ body: comment }),
    });

    if (!updateResponse.ok) {
      throw new Error(
        `Failed to update comment: ${updateResponse.status} ${updateResponse.statusText}`,
      );
    }
    console.log("Updated existing comment");
  } else {
    // Create new comment
    const createResponse = await fetch(apiUrl, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ body: comment }),
    });

    if (!createResponse.ok) {
      throw new Error(
        `Failed to create comment: ${createResponse.status} ${createResponse.statusText}`,
      );
    }
    console.log("Created new comment");
  }
};

/**
 * Main function to process results and post GitHub comment
 */
const main = async (): Promise<void> => {
  // Get environment variables
  const token = process.env.GITHUB_TOKEN;
  const repository = process.env.GITHUB_REPOSITORY; // owner/repo format
  const issueNumber = process.env.GITHUB_ISSUE_NUMBER;
  const inputFile = process.argv[2] || "doc-impact.json";

  if (!token) {
    console.error("Error: GITHUB_TOKEN environment variable is required");
    exit(1);
  }

  if (!repository) {
    console.error("Error: GITHUB_REPOSITORY environment variable is required");
    exit(1);
  }

  if (!issueNumber || isNaN(Number(issueNumber))) {
    console.error(
      "Error: Valid GITHUB_ISSUE_NUMBER environment variable is required",
    );
    exit(1);
  }

  const [owner, repo] = repository.split("/");
  if (!owner || !repo) {
    console.error(
      "Error: Invalid GITHUB_REPOSITORY format. Expected owner/repo",
    );
    exit(1);
  }

  try {
    // Read the analysis results
    const content = await readFile(inputFile, "utf8");
    const results = JSON.parse(content) as DocAnalysisResult[];

    // Create the comment
    const comment = createPRComment(results);

    // Post to GitHub
    await postGitHubComment(owner, repo, Number(issueNumber), comment, token);
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === "ENOENT") {
      console.error(`Error: File not found: ${inputFile}`);
      exit(1);
    }

    if (error instanceof SyntaxError) {
      console.error(`Error: Invalid JSON in ${inputFile}`);
      exit(1);
    }

    console.error(
      `Error: ${error instanceof Error ? error.message : String(error)}`,
    );
    exit(1);
  }
};

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((error) => {
    console.error("Fatal error:", error);
    exit(1);
  });
}
