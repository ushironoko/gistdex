#!/usr/bin/env node

import { readFile } from "node:fs/promises";
import { exit } from "node:process";

interface DocAnalysisResult {
  file: string;
  similarity: number;
  matchedTerms?: string[];
  changeType: "added" | "modified" | "deleted";
  lineNumbers?: number[];
  startLine?: number;
  endLine?: number;
  githubUrl?: string;
}

interface GitHubComment {
  id: number;
  user: {
    type?: string;
  } | null;
  body?: string | null;
}

/**
 * Normalize file paths for GitHub Actions environment
 */
const normalizeFilePath = (filePath: string): string => {
  // Remove GitHub Actions workspace path prefix
  const workspacePrefixes: string[] = [];

  // Get repository name from GITHUB_REPOSITORY env var
  const repository = process.env.GITHUB_REPOSITORY;
  if (repository) {
    const repoName = repository.split("/")[1];
    if (repoName) {
      // Add the standard GitHub Actions workspace path
      workspacePrefixes.push(`/home/runner/work/${repoName}/${repoName}/`);
    }
  }

  // Add GITHUB_WORKSPACE if available
  if (process.env.GITHUB_WORKSPACE) {
    workspacePrefixes.push(`${process.env.GITHUB_WORKSPACE}/`);
  }

  const filteredPrefixes = workspacePrefixes.filter(Boolean);

  for (const prefix of filteredPrefixes) {
    if (filePath.startsWith(prefix)) {
      return filePath.substring(prefix.length);
    }
  }

  // If already a relative path, return as is
  if (!filePath.startsWith("/")) {
    return filePath;
  }

  // For other absolute paths, try to extract relative portion based on repository name
  if (repository) {
    const repoName = repository.split("/")[1];
    if (repoName) {
      const match = filePath.match(new RegExp(`(?:.*/)?${repoName}/(.*)`));
      return match?.[1] ?? filePath;
    }
  }

  return filePath;
};

/**
 * Get change type icon
 */
const getChangeTypeIcon = (changeType: string): string => {
  switch (changeType) {
    case "added":
      return "âž•";
    case "deleted":
      return "âž–";
    default:
      return "ðŸ“";
  }
};

/**
 * Create a GitHub PR comment from documentation analysis results
 */
export const createPRComment = (results: DocAnalysisResult[]): string => {
  if (!Array.isArray(results) || results.length === 0) {
    return `## ðŸ“š Documentation Impact Analysis

âœ… **No documentation impact detected**

All documentation appears to be unaffected by the code changes.`;
  }

  const lines: string[] = ["## ðŸ“š Documentation Impact Analysis", ""];

  // Group by impact level
  const high = results.filter((r) => r.similarity >= 0.8);
  const medium = results.filter(
    (r) => r.similarity >= 0.5 && r.similarity < 0.8,
  );
  const low = results.filter((r) => r.similarity < 0.5);

  if (high.length > 0) {
    lines.push("### ðŸ”´ High Impact (>80% similarity)");
    lines.push("");
    for (const result of high) {
      lines.push(formatResultLine(result));
    }
    lines.push("");
  }

  if (medium.length > 0) {
    lines.push("### ðŸŸ¡ Medium Impact (50-80% similarity)");
    lines.push("");
    for (const result of medium) {
      lines.push(formatResultLine(result));
    }
    lines.push("");
  }

  if (low.length > 0) {
    lines.push("<details>");
    lines.push("<summary>ðŸŸ¢ Low Impact (<50% similarity)</summary>");
    lines.push("");
    for (const result of low) {
      lines.push(formatResultLine(result));
    }
    lines.push("");
    lines.push("</details>");
    lines.push("");
  }

  lines.push("---");
  lines.push("");

  lines.push(
    `ðŸ“Š **Summary**: ${results.length} documentation file${results.length === 1 ? "" : "s"} may need review`,
  );
  lines.push(`ðŸŽ¯ **Threshold**: 70%`);
  lines.push("");
  lines.push(
    "_Generated by [Gistdex CI](https://github.com/ushironoko/gistdex)_",
  );

  return lines.join("\n");
};

/**
 * Format a single result line
 */
const formatResultLine = (result: DocAnalysisResult): string => {
  const similarity = (result.similarity * 100).toFixed(1);
  const changeIcon = getChangeTypeIcon(result.changeType);

  // Normalize file path
  const normalizedFile = normalizeFilePath(result.file);

  // Format file name with optional line numbers link
  let fileDisplay = `\`${normalizedFile}\``;
  if (result.githubUrl && result.startLine && result.endLine) {
    // Add clickable line number range
    fileDisplay += ` [(L${result.startLine}-L${result.endLine})](${result.githubUrl})`;
  } else if (result.githubUrl && result.startLine) {
    // Single line reference
    fileDisplay += ` [(L${result.startLine})](${result.githubUrl})`;
  }

  let line = `- ${changeIcon} **${fileDisplay}** _(${similarity}% similarity)_`;

  if (result.matchedTerms && result.matchedTerms.length > 0) {
    const terms = result.matchedTerms
      .slice(0, 3)
      .map((t: string) => `\`${t}\``)
      .join(", ");
    line += `\n  - Matched: ${terms}`;
    if (result.matchedTerms.length > 3) {
      line += ` +${result.matchedTerms.length - 3} more`;
    }
  }

  return line;
};

/**
 * Post or update a GitHub PR comment
 */
export const postGitHubComment = async (
  owner: string,
  repo: string,
  issueNumber: number,
  comment: string,
  token: string,
): Promise<void> => {
  const apiUrl = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/comments`;

  // Get existing comments
  const listResponse = await fetch(apiUrl, {
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github.v3+json",
    },
  });

  if (!listResponse.ok) {
    throw new Error(
      `Failed to fetch comments: ${listResponse.status} ${listResponse.statusText}`,
    );
  }

  const comments = (await listResponse.json()) as GitHubComment[];

  // Find existing bot comment
  const botComment = comments.find(
    (c) =>
      c.user?.type === "Bot" &&
      c.body?.includes("Documentation Impact Analysis"),
  );

  if (botComment) {
    // Update existing comment
    const updateUrl = `https://api.github.com/repos/${owner}/${repo}/issues/comments/${botComment.id}`;
    const updateResponse = await fetch(updateUrl, {
      method: "PATCH",
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ body: comment }),
    });

    if (!updateResponse.ok) {
      throw new Error(
        `Failed to update comment: ${updateResponse.status} ${updateResponse.statusText}`,
      );
    }
    console.log("Updated existing comment");
  } else {
    // Create new comment
    const createResponse = await fetch(apiUrl, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ body: comment }),
    });

    if (!createResponse.ok) {
      throw new Error(
        `Failed to create comment: ${createResponse.status} ${createResponse.statusText}`,
      );
    }
    console.log("Created new comment");
  }
};

/**
 * Main function to process results and post GitHub comment
 */
const main = async (): Promise<void> => {
  // Get environment variables
  const token = process.env.GITHUB_TOKEN;
  const repository = process.env.GITHUB_REPOSITORY; // owner/repo format
  const issueNumber = process.env.GITHUB_ISSUE_NUMBER;
  const inputFile = process.argv[2] || "doc-impact.json";

  if (!token) {
    console.error("Error: GITHUB_TOKEN environment variable is required");
    exit(1);
  }

  if (!repository) {
    console.error("Error: GITHUB_REPOSITORY environment variable is required");
    exit(1);
  }

  if (!issueNumber || Number.isNaN(Number(issueNumber))) {
    console.error(
      "Error: Valid GITHUB_ISSUE_NUMBER environment variable is required",
    );
    exit(1);
  }

  const [owner, repo] = repository.split("/");
  if (!owner || !repo) {
    console.error(
      "Error: Invalid GITHUB_REPOSITORY format. Expected owner/repo",
    );
    exit(1);
  }

  try {
    // Read the analysis results
    const content = await readFile(inputFile, "utf8");
    const results = JSON.parse(content) as DocAnalysisResult[];

    // Create the comment
    const comment = createPRComment(results);

    // Post to GitHub
    await postGitHubComment(owner, repo, Number(issueNumber), comment, token);
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === "ENOENT") {
      console.error(`Error: File not found: ${inputFile}`);
      exit(1);
    }

    if (error instanceof SyntaxError) {
      console.error(`Error: Invalid JSON in ${inputFile}`);
      exit(1);
    }

    console.error(
      `Error: ${error instanceof Error ? error.message : String(error)}`,
    );
    exit(1);
  }
};

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((error) => {
    console.error("Fatal error:", error);
    exit(1);
  });
}
